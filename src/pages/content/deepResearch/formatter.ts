/**
 * Markdown formatting module for Deep Research thinking content
 */
import { getCurrentLanguage, getTranslation } from '@/utils/i18n';

import type { BrowseChip, ThinkingContent, ThinkingItem, ThinkingSection } from './types';

/**
 * Format a single thought item as Markdown
 */
function formatThoughtItem(header: string, content: string): string {
  if (!header && !content) {
    return '';
  }

  const parts: string[] = [];

  if (header) {
    parts.push(`### ${header}\n`);
  }

  if (content) {
    parts.push(content);
  }

  return parts.join('\n');
}

/**
 * Format browse chips as Markdown list
 */
async function formatBrowseChips(chips: BrowseChip[]): Promise<string> {
  if (chips.length === 0) {
    return '';
  }

  const currentLang = await getCurrentLanguage();
  const researchedWebsitesLabel = await getTranslation('deepResearch_researchedWebsites');

  // If current language is English, only show English label (avoid duplication)
  const header =
    currentLang === 'en'
      ? `#### Researched Websites\n`
      : `#### ${researchedWebsitesLabel} / Researched Websites\n`;

  const lines: string[] = [header];

  chips.forEach((chip) => {
    const title = chip.title ? ` - ${chip.title}` : '';
    lines.push(`- [${chip.domain}](${chip.url})${title}`);
  });

  return lines.join('\n');
}

/**
 * Format a thinking item (either thought or browse chips)
 */
async function formatThinkingItem(item: ThinkingItem): Promise<string> {
  if (item.type === 'thought') {
    return formatThoughtItem(item.header, item.content);
  } else if (item.type === 'browse-chips') {
    return await formatBrowseChips(item.chips);
  }
  return '';
}

/**
 * Format a thinking section as Markdown
 */
async function formatThinkingSection(section: ThinkingSection, index: number): Promise<string> {
  const parts: string[] = [];

  // Section header
  const currentLang = await getCurrentLanguage();
  const thinkingPhaseLabel = await getTranslation('deepResearch_thinkingPhase');

  // If current language is English, only show English label (avoid duplication)
  const header =
    currentLang === 'en'
      ? `## Thinking Phase ${index + 1}\n`
      : `## ${thinkingPhaseLabel} ${index + 1} / Thinking Phase ${index + 1}\n`;

  parts.push(header);

  // Format items in order
  for (const item of section.items) {
    const formatted = await formatThinkingItem(item);
    if (formatted) {
      parts.push(formatted);
      parts.push(''); // Add blank line between items
    }
  }

  return parts.join('\n');
}

/**
 * Format timestamp as readable string
 */
function formatTimestamp(isoString: string): string {
  try {
    const date = new Date(isoString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  } catch (error) {
    console.error('[Gemini Voyager] Error formatting timestamp:', error);
    return isoString;
  }
}

/**
 * Convert thinking content to Markdown format
 */
export async function formatToMarkdown(content: ThinkingContent): Promise<string> {
  const parts: string[] = [];

  // Get current language and translations
  const currentLang = await getCurrentLanguage();
  const exportedAtLabel = await getTranslation('deepResearch_exportedAt');
  const totalPhasesLabel = await getTranslation('deepResearch_totalPhases');

  // Title
  parts.push(`# ${content.title}\n`);

  // Metadata - if current language is English, only show English labels (avoid duplication)
  if (currentLang === 'en') {
    parts.push(`**Exported At:** ${formatTimestamp(content.exportedAt)}\n`);
    parts.push(`**Total Phases:** ${content.sections.length}\n`);
  } else {
    parts.push(`**${exportedAtLabel} / Exported At:** ${formatTimestamp(content.exportedAt)}\n`);
    parts.push(`**${totalPhasesLabel} / Total Phases:** ${content.sections.length}\n`);
  }
  parts.push('---\n');

  // Format each section
  for (let index = 0; index < content.sections.length; index++) {
    const section = content.sections[index];
    const formatted = await formatThinkingSection(section, index);
    if (formatted) {
      parts.push(formatted);
      // Add separator between sections (except for the last one)
      if (index < content.sections.length - 1) {
        parts.push('---\n');
      }
    }
  }

  // Footer
  parts.push('\n---\n');
  parts.push('*Generated by [Gemini Voyager](https://github.com/Nagi-ovo/gemini-voyager)*');

  return parts.join('\n');
}
